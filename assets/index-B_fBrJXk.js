import{r as c,j as x,n as h,h as P,k as E}from"./index-BLkMyUsx.js";function D(e,t){const o=c.createContext(t),u=s=>{const{children:r,...n}=s,a=c.useMemo(()=>n,Object.values(n));return x.jsx(o.Provider,{value:a,children:r})};u.displayName=e+"Provider";function i(s){const r=c.useContext(o);if(r)return r;if(t!==void 0)return t;throw new Error(`\`${s}\` must be used within \`${e}\``)}return[u,i]}function M(e,t=[]){let o=[];function u(s,r){const n=c.createContext(r),a=o.length;o=[...o,r];const d=l=>{const{scope:m,children:p,...v}=l,C=m?.[e]?.[a]||n,w=c.useMemo(()=>v,Object.values(v));return x.jsx(C.Provider,{value:w,children:p})};d.displayName=s+"Provider";function f(l,m){const p=m?.[e]?.[a]||n,v=c.useContext(p);if(v)return v;if(r!==void 0)return r;throw new Error(`\`${l}\` must be used within \`${s}\``)}return[d,f]}const i=()=>{const s=o.map(r=>c.createContext(r));return function(n){const a=n?.[e]||s;return c.useMemo(()=>({[`__scope${e}`]:{...n,[e]:a}}),[n,a])}};return i.scopeName=e,[u,b(i,...t)]}function b(...e){const t=e[0];if(e.length===1)return t;const o=()=>{const u=e.map(i=>({useScope:i(),scopeName:i.scopeName}));return function(s){const r=u.reduce((n,{useScope:a,scopeName:d})=>{const l=a(s)[`__scope${d}`];return{...n,...l}},{});return c.useMemo(()=>({[`__scope${t.scopeName}`]:r}),[r])}};return o.scopeName=t.scopeName,o}var S=globalThis?.document?c.useLayoutEffect:()=>{},$=h[" useId ".trim().toString()]||(()=>{}),R=0;function N(e){const[t,o]=c.useState($());return S(()=>{o(u=>u??String(R++))},[e]),e||(t?`radix-${t}`:"")}var g=h[" useInsertionEffect ".trim().toString()]||S;function k({prop:e,defaultProp:t,onChange:o=()=>{},caller:u}){const[i,s,r]=y({defaultProp:t,onChange:o}),n=e!==void 0,a=n?e:i;{const f=c.useRef(e!==void 0);c.useEffect(()=>{const l=f.current;l!==n&&console.warn(`${u} is changing from ${l?"controlled":"uncontrolled"} to ${n?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),f.current=n},[n,u])}const d=c.useCallback(f=>{if(n){const l=j(f)?f(e):f;l!==e&&r.current?.(l)}else s(f)},[n,e,s,r]);return[a,d]}function y({defaultProp:e,onChange:t}){const[o,u]=c.useState(e),i=c.useRef(o),s=c.useRef(t);return g(()=>{s.current=t},[t]),c.useEffect(()=>{i.current!==o&&(s.current?.(o),i.current=o)},[o,i]),[o,u,s]}function j(e){return typeof e=="function"}var _=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","select","span","svg","ul"],O=_.reduce((e,t)=>{const o=P(`Primitive.${t}`),u=c.forwardRef((i,s)=>{const{asChild:r,...n}=i,a=r?o:t;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),x.jsx(a,{...n,ref:s})});return u.displayName=`Primitive.${t}`,{...e,[t]:u}},{});function L(e,t){e&&E.flushSync(()=>e.dispatchEvent(t))}export{O as P,k as a,N as b,M as c,L as d,D as e,S as u};
